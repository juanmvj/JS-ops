"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReloadBrowserMiddleware = createReloadBrowserMiddleware;

var _path = _interopRequireDefault(require("path"));

var _debounce = _interopRequireDefault(require("debounce"));

var _minimatch = _interopRequireDefault(require("minimatch"));

var _messageChannel = require("./message-channel.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {object} ReloadBrowserMiddlewareConfig
 * @property {string} rootDir
 * @property {import('chokidar').FSWatcher} fileWatcher
 * @property {string[]} watchExcludes
 * @property {number} watchDebounce
 */

/**
 * @param {import('koa').Context} ctx
 * @param {ReloadBrowserMiddlewareConfig} cfg
 * @param {string[]} excludes
 */
async function watchServedFile(ctx, cfg, excludes) {
  // should be a 2xx response
  if (ctx.status < 200 || ctx.status >= 300) {
    return;
  } // should be a file request


  if (!ctx.url.includes('.')) {
    return;
  }

  const filePath = _path.default.join(cfg.rootDir, ctx.url.split('?')[0].split('#')[0]); // the path is excluded (for example node_modules)


  if (excludes.some(pattern => (0, _minimatch.default)(filePath, pattern))) {
    return;
  }

  cfg.fileWatcher.add(filePath);
}

function onFileChanged() {
  (0, _messageChannel.sendMessageToActiveBrowsers)('file-changed');
}
/**
 * Sets up a middleware which tracks served files and sends a reload message to any
 * active browsers when any of the files change.
 *
 * @param {ReloadBrowserMiddlewareConfig} cfg
 */


function createReloadBrowserMiddleware(cfg) {
  const excludes = cfg.watchExcludes.map(e => _path.default.join(cfg.rootDir, e));
  cfg.fileWatcher.addListener('change', (0, _debounce.default)(onFileChanged, cfg.watchDebounce));
  /** @type {import('koa').Middleware} */

  async function reloadBrowserMiddleware(ctx, next) {
    await next();
    watchServedFile(ctx, cfg, excludes);
  }

  return reloadBrowserMiddleware;
}